<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âpicerie Interactive en Rabais (Version Texte)</title>
    <style>
        :root {
            --bg-color: #f4f7f6; --card-bg-color: #ffffff; --text-color: #333; --text-color-light: #666;
            --border-color: #e0e0e0; --header-bg-color: #4CAF50; --header-text-color: #ffffff;
            --row-hover-bg-color: #f1f1f1; --input-bg-color: #fdfdfd; --input-border-color: #ccc;
        }
        body.dark-mode {
            --bg-color: #212529; --card-bg-color: #343a40; --text-color: #f8f9fa; --text-color-light: #adb5bd;
            --border-color: #495057; --header-bg-color: #2c5f2d; --header-text-color: #ffffff;
            --row-hover-bg-color: #495057; --input-bg-color: #495057; --input-border-color: #6c757d;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; background-color: var(--bg-color); color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        .container { padding: 10px; }
        h1 { text-align: center; color: var(--header-bg-color); margin-bottom: 0.5rem; font-size: 2em; }
        .subtitle { text-align: center; font-size: 1rem; font-weight: 400; color: var(--text-color-light); margin-top: -10px; margin-bottom: 25px; }
        .controls-grid {
            max-width: 1400px; margin: 0 auto 20px auto; padding: 20px; background-color: var(--card-bg-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-radius: 12px;
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { font-weight: 500; font-size: 14px; color: var(--text-color-light); }
        .controls-grid input[type="text"] {
            width: 100%; padding: 10px; border-radius: 5px; border: 1px solid var(--input-border-color);
            background-color: var(--input-bg-color); color: var(--text-color); font-size: 16px;
        }
        .checkbox-container, .button-container {
            grid-column: 1 / -1; display: flex; flex-wrap: wrap; gap: 10px 15px; margin-top: 10px;
        }
        .checkbox-container label { display: flex; align-items: center; gap: 8px; font-size: 16px; cursor: pointer; user-select: none; }
        .type-button {
            padding: 8px 16px; border-radius: 20px; border: 1px solid var(--input-border-color);
            background-color: var(--input-bg-color); color: var(--text-color); font-size: 14px;
            cursor: pointer; transition: background-color 0.2s, color 0.2s;
        }
        .type-button.active { background-color: var(--header-bg-color); color: var(--header-text-color); border-color: var(--header-bg-color); }
        .theme-switch-wrapper { display: flex; align-items: center; justify-self: end; gap: 10px; }
        .slider { background-color: #ccc; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 24px; }
        .slider:before { background-color: #fff; bottom: 4px; content: ""; height: 16px; left: 4px; position: absolute; transition: .4s; width: 16px; border-radius: 50%; }
        input:checked + .slider { background-color: var(--header-bg-color); }
        input:checked + .slider:before { transform: translateX(26px); }
        .theme-switch { display: inline-block; height: 24px; position: relative; width: 50px; }
        .theme-switch input { display:none; }
        
        .item-count {
            max-width: 1400px; margin: -10px auto 15px; text-align: center; color: var(--text-color-light); font-size: 0.9em;
        }

        #table-container {
            margin: auto; max-width: 1400px; background-color: var(--card-bg-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-radius: 12px; overflow: hidden;
            overflow-x: auto;
        }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 16px 20px; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle; }
        thead th {
            background-color: var(--header-bg-color); color: var(--header-text-color); font-weight: 600;
            position: sticky; top: 0; z-index: 10; white-space: nowrap;
        }
        th[data-sortable] { cursor: pointer; user-select: none; }
        .sort-indicator { font-size: 0.8em; margin-left: 5px; }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--row-hover-bg-color); }
        .loading, .error, .no-results { text-align: center; padding: 40px; font-size: 1.2em; color: var(--text-color-light); }
        
        @media (max-width: 768px) {
            .container { padding: 5px; } h1 { font-size: 1.5em; } .subtitle { font-size: 0.9em; }
            .controls-grid { grid-template-columns: 1fr; }
            th, td { padding: 12px 10px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>√âpicerie Interactive en Rabais</h1>
        <h2 class="subtitle">
            Ma liste d'√©picerie personnalis√©e √† partir du 20 novembre<br>
            par /u/eranumerique, https://eranumerique.github.io/
        </h2>

        <div class="controls-grid">
            <div class="control-group" style="grid-column: 1 / -1;"><label for="search-input">Rechercher</label><input type="text" id="search-input" placeholder="üîç Trouver un article..."></div>
            <div class="theme-switch-wrapper">
                <span>‚òÄÔ∏è</span>
                <label class="theme-switch"><input type="checkbox" id="darkModeToggle"><span class="slider"></span></label>
                <span>üåô</span>
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <label>Filtrer par type</label>
                <div id="type-button-container" class="button-container"></div>
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <label>Filtrer par magasin</label>
                <div id="store-checkbox-container" class="checkbox-container"></div>
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <label>Afficher les colonnes</label>
                <div id="column-toggle-container" class="checkbox-container"></div>
            </div>
        </div>

        <div id="item-count" class="item-count"></div>

        <div id="table-container"><div class="loading">Chargement des donn√©es...</div></div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const ui = {
            tableContainer: document.getElementById('table-container'),
            searchInput: document.getElementById('search-input'),
            typeButtonContainer: document.getElementById('type-button-container'),
            storeCheckboxContainer: document.getElementById('store-checkbox-container'),
            columnToggleContainer: document.getElementById('column-toggle-container'),
            darkModeToggle: document.getElementById('darkModeToggle'),
            itemCount: document.getElementById('item-count'),
        };

        let allGroceries = [];
        let tableHeaders = [];
        let currentSort = { column: null, direction: 'asc' };
        
        const KEYS = {
            THEME: 'groceryTableTheme',
            STORES: 'groceryStoreSelection',
            COLUMNS: 'groceryColumnVisibility'
        };

        function applyTheme(theme) {
            document.body.classList.toggle('dark-mode', theme === 'dark');
            ui.darkModeToggle.checked = (theme === 'dark');
        }

        async function initializeApp() {
            applyTheme(localStorage.getItem(KEYS.THEME) || 'dark');

            try {
                const mdRes = await fetch('Liste/Tableau.md');
                if (!mdRes.ok) throw new Error(`√âchec du chargement du fichier de donn√©es. V√©rifiez le chemin du fichier.`);
                const tableMdText = await mdRes.text();
                
                tableHeaders = extractHeadersFromMarkdown(tableMdText);
                allGroceries = parseMarkdownTable(tableMdText, tableHeaders);
                
                populateFilters();
                renderTable();
            } catch (error) {
                console.error('Erreur d\'initialisation:', error);
                ui.tableContainer.innerHTML = `<div class="error">Impossible de charger les donn√©es d'√©picerie. ${error.message}</div>`;
            }
        }

        function populateFilters() {
            const stores = [...new Set(allGroceries.map(item => item.magasin))].filter(Boolean).sort();
            const types = [...new Set(allGroceries.map(item => item.type))].filter(Boolean).sort();
            
            ['Tous les types', ...types].forEach(type => {
                const button = document.createElement('button');
                button.className = 'type-button';
                button.textContent = type;
                button.dataset.type = (type === 'Tous les types') ? 'all' : type;
                if (type === 'Tous les types') button.classList.add('active');
                button.addEventListener('click', handleTypeFilterClick);
                ui.typeButtonContainer.appendChild(button);
            });

            const savedStores = JSON.parse(localStorage.getItem(KEYS.STORES));
            stores.forEach(store => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = store;
                checkbox.checked = (savedStores === null || savedStores.length === 0) ? true : savedStores.includes(store);
                checkbox.addEventListener('change', () => { savePreferences(KEYS.STORES, getCheckedValues(ui.storeCheckboxContainer)); renderTable(); });
                label.append(checkbox, store);
                ui.storeCheckboxContainer.appendChild(label);
            });

            const savedColumns = JSON.parse(localStorage.getItem(KEYS.COLUMNS));
            tableHeaders.forEach(header => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = header.key;
                checkbox.checked = (savedColumns === null) ? true : savedColumns.includes(header.key);
                checkbox.addEventListener('change', () => { savePreferences(KEYS.COLUMNS, getCheckedValues(ui.columnToggleContainer)); renderTable(); });
                label.append(checkbox, header.text);
                ui.columnToggleContainer.appendChild(label);
            });
        }
        
        function savePreferences(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
        function getCheckedValues(container) { return Array.from(container.querySelectorAll('input:checked')).map(cb => cb.value); }

        function renderTable() {
            let data = [...allGroceries];
            const searchTerm = ui.searchInput.value.toLowerCase();
            const selectedType = ui.typeButtonContainer.querySelector('.active').dataset.type;
            const selectedStores = getCheckedValues(ui.storeCheckboxContainer);

            if (searchTerm) data = data.filter(i => Object.values(i).some(val => String(val).toLowerCase().includes(searchTerm)));
            if (selectedType !== 'all') data = data.filter(i => i.type === selectedType);
            data = data.filter(i => selectedStores.includes(i.magasin));

            const totalCount = allGroceries.length;
            const filteredCount = data.length;
            const productString = filteredCount <= 1 ? 'produit' : 'produits';
            ui.itemCount.textContent = `Affichage de ${filteredCount} ${productString} sur ${totalCount} au total.`;
            
            if (currentSort.column) {
                data.sort((a, b) => {
                    const valA = a[currentSort.column] || '', valB = b[currentSort.column] || '';
                    let comp = 0;
                    const isNumericSort = ['prix', 'kg'].some(kw => currentSort.column.toLowerCase().includes(kw));
                    if (isNumericSort) {
                        const priceA = parseFloat(String(valA).replace(/[^0-9,]/g, '').replace(',', '.')) || 0;
                        const priceB = parseFloat(String(valB).replace(/[^0-9,]/g, '').replace(',', '.')) || 0;
                        comp = priceA > priceB ? 1 : -1;
                    } else { comp = String(valA).localeCompare(String(valB), 'fr', { sensitivity: 'base' }); }
                    return currentSort.direction === 'desc' ? comp * -1 : comp;
                });
            }
            buildTableHTML(data);
        }
        
        function buildTableHTML(data) {
            ui.tableContainer.innerHTML = data.length === 0 ? `<div class="no-results">Aucun article ne correspond √† vos filtres.</div>` : '';
            if (data.length === 0) return;

            const visibleColumnKeys = getCheckedValues(ui.columnToggleContainer);
            const visibleHeaders = tableHeaders.filter(h => visibleColumnKeys.includes(h.key));
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            
            const headerRow = document.createElement('tr');
            visibleHeaders.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h.text;
                if (h.sortable) {
                    th.dataset.sortable = true; th.dataset.column = h.key;
                    if (currentSort.column === h.key) th.innerHTML += `<span class="sort-indicator">${currentSort.direction === 'asc' ? '‚ñ≤' : '‚ñº'}</span>`;
                    th.addEventListener('click', handleSort);
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            
            data.forEach(row => {
                const tr = document.createElement('tr');
                visibleHeaders.forEach(header => {
                    const td = document.createElement('td');
                    td.innerHTML = (row[header.key] || '').replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            
            table.append(thead, tbody);
            ui.tableContainer.appendChild(table);
        }

        function handleTypeFilterClick(e) {
            ui.typeButtonContainer.querySelector('.active').classList.remove('active');
            e.currentTarget.classList.add('active');
            renderTable();
        }

        function handleSort(e) {
            const column = e.currentTarget.dataset.column;
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column; currentSort.direction = 'asc';
            }
            renderTable();
        }

        // CORRECTED: This version no longer adds a fake "image" header
        function extractHeadersFromMarkdown(md) {
            const headerLine = md.trim().split('\n')[0];
            const headerNames = headerLine.split('|').map(h => h.trim()).filter(Boolean);
            const createKey = (text) => text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, '');

            let headers = [];
            headerNames.forEach(name => {
                const key = createKey(name);
                headers.push({ key, text: name, sortable: !['emoji'].includes(key) });
            });
            return headers;
        }

        // CORRECTED: This version correctly maps the headers to the data cells
        function parseMarkdownTable(md, headers) {
            const dataRows = md.trim().split('\n').slice(2);
            return dataRows.map(line => {
                const cells = line.split('|').map(c => c.trim()).slice(1, -1);
                const rowData = {};
                headers.forEach((header, index) => {
                    // This now works because the number of headers matches the number of cells
                    if (cells[index] !== undefined) {
                       rowData[header.key] = cells[index];
                    }
                });
                return rowData;
            });
        }

        ui.darkModeToggle.addEventListener('change', () => {
            const newTheme = ui.darkModeToggle.checked ? 'dark' : 'light';
            savePreferences(KEYS.THEME, newTheme); applyTheme(newTheme);
        });
        ui.searchInput.addEventListener('input', renderTable);

        initializeApp();
    });
</script>
</body>
</html>